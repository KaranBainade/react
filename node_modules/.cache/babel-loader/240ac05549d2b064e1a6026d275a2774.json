{"ast":null,"code":"import { __assign, __extends, __read, __spread } from \"tslib\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport UIAnalyticsEvent from './UIAnalyticsEvent';\n/**\n * This component is used to grab the analytics functions off context.\n * It uses legacy context, but provides an API similar to 16.3 context.\n * This makes it easier to use with the forward ref API.\n */\n\nvar AnalyticsContextConsumer =\n/** @class */\nfunction (_super) {\n  __extends(AnalyticsContextConsumer, _super);\n\n  function AnalyticsContextConsumer(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * Store references to the original and patched event props so we can\n     * determine when to update the patched props\n     */\n\n\n    _this.originalEventProps = {};\n    _this.patchedEventProps = {}; // Update patched event props only if the original props have changed\n\n    _this.updatePatchedEventProps = function (props) {\n      var changedPropCallbacks = Object.keys(_this.props.createEventMap).filter(function (p) {\n        return _this.originalEventProps[p] !== props[p];\n      });\n\n      if (changedPropCallbacks.length > 0) {\n        _this.patchedEventProps = __assign(__assign({}, _this.patchedEventProps), _this.mapCreateEventsToProps(changedPropCallbacks, props));\n        changedPropCallbacks.forEach(function (p) {\n          _this.originalEventProps[p] = props[p];\n        });\n      }\n\n      return _this.patchedEventProps;\n    };\n\n    _this.mapCreateEventsToProps = function (changedPropNames, props) {\n      return changedPropNames.reduce(function (modified, propCallbackName) {\n        var _a;\n\n        var eventCreator = _this.props.createEventMap[propCallbackName];\n        var providedCallback = props[propCallbackName];\n\n        if (!['object', 'function'].includes(typeof eventCreator)) {\n          return modified;\n        }\n\n        var modifiedCallback = function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          var analyticsEvent = typeof eventCreator === 'function' ? eventCreator(_this.createAnalyticsEvent, props) : _this.createAnalyticsEvent(eventCreator);\n\n          if (providedCallback) {\n            providedCallback.apply(void 0, __spread(args, [analyticsEvent]));\n          }\n        };\n\n        return __assign(__assign({}, modified), (_a = {}, _a[propCallbackName] = modifiedCallback, _a));\n      }, {});\n    };\n\n    _this.createAnalyticsEvent = function (payload) {\n      var _a = _this.context,\n          getAtlaskitAnalyticsEventHandlers = _a.getAtlaskitAnalyticsEventHandlers,\n          getAtlaskitAnalyticsContext = _a.getAtlaskitAnalyticsContext;\n      return new UIAnalyticsEvent({\n        context: typeof getAtlaskitAnalyticsContext === 'function' && getAtlaskitAnalyticsContext() || [],\n        handlers: typeof getAtlaskitAnalyticsEventHandlers === 'function' && getAtlaskitAnalyticsEventHandlers() || [],\n        payload: payload\n      });\n    };\n\n    Object.keys(_this.props.createEventMap).forEach(function (p) {\n      _this.originalEventProps[p] = props.wrappedComponentProps[p];\n    });\n    _this.patchedEventProps = _this.mapCreateEventsToProps(Object.keys(_this.props.createEventMap), props.wrappedComponentProps);\n    return _this;\n  }\n\n  AnalyticsContextConsumer.prototype.render = function () {\n    var patchedEventProps = this.updatePatchedEventProps(this.props.wrappedComponentProps);\n    return this.props.children({\n      createAnalyticsEvent: this.createAnalyticsEvent,\n      patchedEventProps: patchedEventProps\n    });\n  };\n\n  AnalyticsContextConsumer.contextTypes = {\n    getAtlaskitAnalyticsEventHandlers: PropTypes.func,\n    getAtlaskitAnalyticsContext: PropTypes.func\n  };\n  AnalyticsContextConsumer.defaultProps = {\n    createEventMap: {}\n  };\n  return AnalyticsContextConsumer;\n}(React.Component);\n\nexport default AnalyticsContextConsumer;","map":{"version":3,"sources":["../../src/AnalyticsContextConsumer.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAP,MAAkB,OAAlB;AACA,OAAO,SAAP,MAAsB,YAAtB;AAOA,OAAO,gBAAP,MAA6B,oBAA7B;AAYA;;;;;;AAKA,IAAA,wBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAEU,EAAA,SAAA,CAAA,wBAAA,EAAA,MAAA,CAAA;;AAiBR,WAAA,wBAAA,CAAY,KAAZ,EAAuD;AAAvD,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,KAAY,IADd;AAPA;;;;;;AAIA,IAAA,KAAA,CAAA,kBAAA,GAAqC,EAArC;AACA,IAAA,KAAA,CAAA,iBAAA,GAAoC,EAApC,CAEuD,CAavD;;AACA,IAAA,KAAA,CAAA,uBAAA,GAA0B,UAAC,KAAD,EAAa;AACrC,UAAM,oBAAoB,GAAG,MAAM,CAAC,IAAP,CAAY,KAAI,CAAC,KAAL,CAAW,cAAvB,EAAuC,MAAvC,CAC3B,UAAA,CAAA,EAAC;AAAI,eAAA,KAAI,CAAC,kBAAL,CAAwB,CAAxB,MAA+B,KAAK,CAApC,CAAoC,CAApC;AAAuC,OADjB,CAA7B;;AAGA,UAAI,oBAAoB,CAAC,MAArB,GAA8B,CAAlC,EAAqC;AACnC,QAAA,KAAI,CAAC,iBAAL,GAAsB,QAAA,CAAA,QAAA,CAAA,EAAA,EACjB,KAAI,CAAC,iBADY,CAAA,EAEjB,KAAI,CAAC,sBAAL,CAA4B,oBAA5B,EAAkD,KAAlD,CAFiB,CAAtB;AAIA,QAAA,oBAAoB,CAAC,OAArB,CAA6B,UAAA,CAAA,EAAC;AAC5B,UAAA,KAAI,CAAC,kBAAL,CAAwB,CAAxB,IAA6B,KAAK,CAAC,CAAD,CAAlC;AACD,SAFD;AAGD;;AAED,aAAO,KAAI,CAAC,iBAAZ;AACD,KAfD;;AAiBA,IAAA,KAAA,CAAA,sBAAA,GAAyB,UAAC,gBAAD,EAA6B,KAA7B,EAAyC;AAChE,aAAA,gBAAgB,CAAC,MAAjB,CAAwB,UAAC,QAAD,EAAW,gBAAX,EAA2B;;;AACjD,YAAM,YAAY,GAAG,KAAI,CAAC,KAAL,CAAW,cAAX,CAA0B,gBAA1B,CAArB;AACA,YAAM,gBAAgB,GAAG,KAAK,CAAC,gBAAD,CAA9B;;AAEA,YAAI,CAAC,CAAC,QAAD,EAAW,UAAX,EAAuB,QAAvB,CAAgC,OAAO,YAAvC,CAAL,EAA2D;AACzD,iBAAO,QAAP;AACD;;AAED,YAAM,gBAAgB,GAAG,YAAA;AAAC,cAAA,IAAA,GAAA,EAAA;;eAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAc;AAAd,YAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACxB,cAAM,cAAc,GAClB,OAAO,YAAP,KAAwB,UAAxB,GACK,YAAsC,CACrC,KAAI,CAAC,oBADgC,EAErC,KAFqC,CAD3C,GAKI,KAAI,CAAC,oBAAL,CAA0B,YAA1B,CANN;;AAQA,cAAI,gBAAJ,EAAsB;AACpB,YAAA,gBAAgB,CAAA,KAAhB,CAAgB,KAAA,CAAhB,EAAgB,QAAA,CAAI,IAAJ,EAAQ,CAAE,cAAF,CAAR,CAAhB;AACD;AACF,SAZD;;AAcA,eAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACK,QADL,CAAA,GACa,EAAA,GAAA,EAAA,EAAA,EAAA,CACV,gBADU,CAAA,GACS,gBADT,EACyB,EAFtC,EAAA;AAID,OA1BD,EA0BG,EA1BH,CAAA;AA0BM,KA3BR;;AA6BA,IAAA,KAAA,CAAA,oBAAA,GAAuB,UAAC,OAAD,EAA+B;AAC9C,UAAA,EAAA,GAAA,KAAA,CAAA,OAAA;AAAA,UACJ,iCAAA,GAAA,EAAA,CAAA,iCADI;AAAA,UAEJ,2BAAA,GAAA,EAAA,CAAA,2BAFI;AAKN,aAAO,IAAI,gBAAJ,CAAqB;AAC1B,QAAA,OAAO,EACJ,OAAO,2BAAP,KAAuC,UAAvC,IACC,2BAA2B,EAD7B,IAEA,EAJwB;AAK1B,QAAA,QAAQ,EACL,OAAO,iCAAP,KAA6C,UAA7C,IACC,iCAAiC,EADnC,IAEA,EARwB;AAS1B,QAAA,OAAO,EAAA;AATmB,OAArB,CAAP;AAWD,KAjBD;;AAzDE,IAAA,MAAM,CAAC,IAAP,CAAY,KAAI,CAAC,KAAL,CAAW,cAAvB,EAAuC,OAAvC,CAA+C,UAAA,CAAA,EAAC;AAC9C,MAAA,KAAI,CAAC,kBAAL,CAAwB,CAAxB,IAA6B,KAAK,CAAC,qBAAN,CAA4B,CAA5B,CAA7B;AACD,KAFD;AAIA,IAAA,KAAI,CAAC,iBAAL,GAAyB,KAAI,CAAC,sBAAL,CACvB,MAAM,CAAC,IAAP,CAAY,KAAI,CAAC,KAAL,CAAW,cAAvB,CADuB,EAEvB,KAAK,CAAC,qBAFiB,CAAzB;;AAID;;AAoED,EAAA,wBAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;AACE,QAAM,iBAAiB,GAAG,KAAK,uBAAL,CACxB,KAAK,KAAL,CAAW,qBADa,CAA1B;AAIA,WAAO,KAAK,KAAL,CAAW,QAAX,CAAoB;AACzB,MAAA,oBAAoB,EAAE,KAAK,oBADF;AAEzB,MAAA,iBAAiB,EAAA;AAFQ,KAApB,CAAP;AAID,GATD;;AA/FO,EAAA,wBAAA,CAAA,YAAA,GAAe;AACpB,IAAA,iCAAiC,EAAE,SAAS,CAAC,IADzB;AAEpB,IAAA,2BAA2B,EAAE,SAAS,CAAC;AAFnB,GAAf;AAKA,EAAA,wBAAA,CAAA,YAAA,GAAe;AACpB,IAAA,cAAc,EAAE;AADI,GAAf;AAoGT,SAAA,wBAAA;AAAC,CA5GD,CAEU,KAAK,CAAC,SAFhB,CAAA;;AA8GA,eAAe,wBAAf","sourceRoot":"","sourcesContent":["import { __assign, __extends, __read, __spread } from \"tslib\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport UIAnalyticsEvent from './UIAnalyticsEvent';\n/**\n * This component is used to grab the analytics functions off context.\n * It uses legacy context, but provides an API similar to 16.3 context.\n * This makes it easier to use with the forward ref API.\n */\nvar AnalyticsContextConsumer = /** @class */ (function (_super) {\n    __extends(AnalyticsContextConsumer, _super);\n    function AnalyticsContextConsumer(props) {\n        var _this = _super.call(this, props) || this;\n        /**\n         * Store references to the original and patched event props so we can\n         * determine when to update the patched props\n         */\n        _this.originalEventProps = {};\n        _this.patchedEventProps = {};\n        // Update patched event props only if the original props have changed\n        _this.updatePatchedEventProps = function (props) {\n            var changedPropCallbacks = Object.keys(_this.props.createEventMap).filter(function (p) { return _this.originalEventProps[p] !== props[p]; });\n            if (changedPropCallbacks.length > 0) {\n                _this.patchedEventProps = __assign(__assign({}, _this.patchedEventProps), _this.mapCreateEventsToProps(changedPropCallbacks, props));\n                changedPropCallbacks.forEach(function (p) {\n                    _this.originalEventProps[p] = props[p];\n                });\n            }\n            return _this.patchedEventProps;\n        };\n        _this.mapCreateEventsToProps = function (changedPropNames, props) {\n            return changedPropNames.reduce(function (modified, propCallbackName) {\n                var _a;\n                var eventCreator = _this.props.createEventMap[propCallbackName];\n                var providedCallback = props[propCallbackName];\n                if (!['object', 'function'].includes(typeof eventCreator)) {\n                    return modified;\n                }\n                var modifiedCallback = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    var analyticsEvent = typeof eventCreator === 'function'\n                        ? eventCreator(_this.createAnalyticsEvent, props)\n                        : _this.createAnalyticsEvent(eventCreator);\n                    if (providedCallback) {\n                        providedCallback.apply(void 0, __spread(args, [analyticsEvent]));\n                    }\n                };\n                return __assign(__assign({}, modified), (_a = {}, _a[propCallbackName] = modifiedCallback, _a));\n            }, {});\n        };\n        _this.createAnalyticsEvent = function (payload) {\n            var _a = _this.context, getAtlaskitAnalyticsEventHandlers = _a.getAtlaskitAnalyticsEventHandlers, getAtlaskitAnalyticsContext = _a.getAtlaskitAnalyticsContext;\n            return new UIAnalyticsEvent({\n                context: (typeof getAtlaskitAnalyticsContext === 'function' &&\n                    getAtlaskitAnalyticsContext()) ||\n                    [],\n                handlers: (typeof getAtlaskitAnalyticsEventHandlers === 'function' &&\n                    getAtlaskitAnalyticsEventHandlers()) ||\n                    [],\n                payload: payload,\n            });\n        };\n        Object.keys(_this.props.createEventMap).forEach(function (p) {\n            _this.originalEventProps[p] = props.wrappedComponentProps[p];\n        });\n        _this.patchedEventProps = _this.mapCreateEventsToProps(Object.keys(_this.props.createEventMap), props.wrappedComponentProps);\n        return _this;\n    }\n    AnalyticsContextConsumer.prototype.render = function () {\n        var patchedEventProps = this.updatePatchedEventProps(this.props.wrappedComponentProps);\n        return this.props.children({\n            createAnalyticsEvent: this.createAnalyticsEvent,\n            patchedEventProps: patchedEventProps,\n        });\n    };\n    AnalyticsContextConsumer.contextTypes = {\n        getAtlaskitAnalyticsEventHandlers: PropTypes.func,\n        getAtlaskitAnalyticsContext: PropTypes.func,\n    };\n    AnalyticsContextConsumer.defaultProps = {\n        createEventMap: {},\n    };\n    return AnalyticsContextConsumer;\n}(React.Component));\nexport default AnalyticsContextConsumer;\n//# sourceMappingURL=AnalyticsContextConsumer.js.map"]},"metadata":{},"sourceType":"module"}