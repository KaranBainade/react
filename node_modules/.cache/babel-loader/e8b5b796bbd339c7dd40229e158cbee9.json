{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { useCallback, useRef, useEffect } from 'react';\nimport { useAnalyticsEvents } from './useAnalyticsEvents';\nexport var useCallbackWithAnalytics = function (method, payload, channel) {\n  var createAnalyticsEvent = useAnalyticsEvents().createAnalyticsEvent; // given input might be new function/object each render\n  // we optimise and store in refs so we can memoize the callback\n  // and at the same time avoid stale values\n\n  var methodRef = useRef(method);\n  var payloadRef = useRef(payload);\n  useEffect(function () {\n    methodRef.current = method;\n    payloadRef.current = payload;\n  }, [method, payload]);\n  return useCallback(function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var pload = typeof payloadRef.current === 'function' ? payloadRef.current.apply(payloadRef, __spread(args)) : payloadRef.current;\n    createAnalyticsEvent(pload).fire(channel);\n    methodRef.current.apply(methodRef, __spread(args));\n  }, [createAnalyticsEvent, methodRef, payloadRef, channel]);\n};","map":{"version":3,"sources":["../../src/useCallbackWithAnalytics.tsx"],"names":[],"mappings":";AAAA,SAAS,WAAT,EAAsB,MAAtB,EAA8B,SAA9B,QAA+C,OAA/C;AACA,SAAS,kBAAT,QAAmC,sBAAnC;AAQA,OAAO,IAAM,wBAAwB,GAAiC,UACpE,MADoE,EAEpE,OAFoE,EAGpE,OAHoE,EAG7D;AAEC,MAAA,oBAAA,GAAA,kBAAA,GAAA,oBAAA,CAFD,CAIP;AACA;AACA;;AACA,MAAM,SAAS,GAAG,MAAM,CAAC,MAAD,CAAxB;AACA,MAAM,UAAU,GAAG,MAAM,CAAC,OAAD,CAAzB;AAEA,EAAA,SAAS,CAAC,YAAA;AACR,IAAA,SAAS,CAAC,OAAV,GAAoB,MAApB;AACA,IAAA,UAAU,CAAC,OAAX,GAAqB,OAArB;AACD,GAHQ,EAGN,CAAC,MAAD,EAAS,OAAT,CAHM,CAAT;AAKA,SAAO,WAAW,CAChB,YAAA;AAAC,QAAA,IAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAO;AAAP,MAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACC,QAAM,KAAK,GACT,OAAO,UAAU,CAAC,OAAlB,KAA8B,UAA9B,GACI,UAAU,CAAC,OAAX,CAAkB,KAAlB,CAAA,UAAA,EAAU,QAAA,CAAY,IAAZ,CAAV,CADJ,GAEI,UAAU,CAAC,OAHjB;AAIA,IAAA,oBAAoB,CAAC,KAAD,CAApB,CAA4B,IAA5B,CAAiC,OAAjC;AACA,IAAA,SAAS,CAAC,OAAV,CAAiB,KAAjB,CAAA,SAAA,EAAS,QAAA,CAAY,IAAZ,CAAT;AACD,GARe,EAShB,CAAC,oBAAD,EAAuB,SAAvB,EAAkC,UAAlC,EAA8C,OAA9C,CATgB,CAAlB;AAWD,CA7BM","sourceRoot":"","sourcesContent":["import { __read, __spread } from \"tslib\";\nimport { useCallback, useRef, useEffect } from 'react';\nimport { useAnalyticsEvents } from './useAnalyticsEvents';\nexport var useCallbackWithAnalytics = function (method, payload, channel) {\n    var createAnalyticsEvent = useAnalyticsEvents().createAnalyticsEvent;\n    // given input might be new function/object each render\n    // we optimise and store in refs so we can memoize the callback\n    // and at the same time avoid stale values\n    var methodRef = useRef(method);\n    var payloadRef = useRef(payload);\n    useEffect(function () {\n        methodRef.current = method;\n        payloadRef.current = payload;\n    }, [method, payload]);\n    return useCallback(function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var pload = typeof payloadRef.current === 'function'\n            ? payloadRef.current.apply(payloadRef, __spread(args)) : payloadRef.current;\n        createAnalyticsEvent(pload).fire(channel);\n        methodRef.current.apply(methodRef, __spread(args));\n    }, [createAnalyticsEvent, methodRef, payloadRef, channel]);\n};\n//# sourceMappingURL=useCallbackWithAnalytics.js.map"]},"metadata":{},"sourceType":"module"}